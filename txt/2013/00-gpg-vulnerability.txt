$date
2013-01-14

$title
Finding a gpg vulnerability by fuzzing

<img src="/media/img/502abd76f3682563debb6c0b7f342d224b17a402.png"
class="lead_initial" alt="heatmap"/>
I recently found a <a
href="http://www.securityfocus.com/bid/57102/info">GnuPG
vulnerability</a> while testing my java-based OpenPGP code. I'll use
this as an excuse to post about testing security code and OpenPGP in
particular, but put it in context with this real-life bug.

A small digression first. Writing security-related software has to be
one of the most thankless jobs a programmer can do. You are a nuisance
to everyone, but the one time everyone knows what you're doing is when
you've made a mistake. At that point you're hung out to dry along your
bug for everyone to poke at and feel smug about. So no programmer
should cast stones here, for let he who is without sin, etc.

I'm just a satisfied user of <tt>gpg</tt>, and I'd like to put in a
plug for the GnuPG maintainers. They've been at this thankless job for
a decade and a half, while fixing bugs efficiently and openly. Being
GNU/libre software, what keeps them going is mainly a desire to
contribute to the community. So please say thank you by <a
href="http://g10code.com/gnupg-donation.html">giving something
back</a> to them if you find <tt>gpg</tt> useful.

$asis
<h2>Fuzzing inputs</h2>

While you can prove some security results in crypto mathematics,
there's no equivalent for crypto <em>programming</em>. The only
practical way to know anything about the security of your code is to
test it in as many different ways as you can cook up.

A surprisingly productive technique is <a
href="https://en.wikipedia.org/wiki/Fuzz_testing">fuzz testing</a>,
where you throw lots of random inputs at every part of your program
that reads data.

I'll focus on a specific variation called mutation fuzzing, where you
start with a good input and then change parts of it randomly. This
idea can be automated easily as it needs little or no knowledge about
the data itself. The only thing you need to do is to ensure your code
can conveniently accept data from a script.

I was writing some java code that saved and read OpenPGP public
keys. So I began by using a good public key, then randomly changed one
byte at a time and read it back into the app to see what it did.

I won't trouble you with the many ways I was chastened by this
experiment! But I also used <tt>gpg 1.4.11</tt> as a control
application to read the same inputs, and started to see it do some odd
things.

<img src="/media/img/502abd76f3682563debb6c0b7f342d224b17a402.png" class="half" alt="heatmap"/>
Here is a heat-map of <tt>gpg</tt>'s behavior when fuzzing some public
key. Each little square is a byte in the key, and a byte gets redder
if <tt>gpg</tt> imports the key even if that byte is modified.

That is, I repeatedly change just the first byte in the key and see if
<tt>gpg</tt> still imports it. If it never imports the key, I color the first
square nearly white. Otherwise I color it redder, depending on how
often <tt>gpg</tt> imports it. Then I change just the second byte, and so on.

The first surprise is that you see <tt>gpg</tt> generally imports the key
even if you change any of the bytes in the second half of the key. You
might think that <tt>gpg</tt> should never import a key if anything was
changed in it, but the truth is a bit more complex and you'll soon see
why.

You also see a few red squares in the first half, and some not-so-red
squares in the second half. So <tt>gpg</tt> occasionally accepts keys modified
within the first half too, and it doesn't consistently import every
key from a modified second half either.

To understand what's going on, you have to know a bit about how
OpenPGP organizes its data. This is going to get long and detailed,
but I promise there is a payoff at the end.

$asis
<h2>OpenPGP packet structure</h2>

<a href="https://tools.ietf.org/html/rfc4880">OpenPGP</a> is a binary,
byte-oriented data format. While you often see PGP ASCII messages,
these are just ASCII encodings of the underlying binary data. I'll
only talk about the binary format from here on.

This binary format is a concatenated sequence of <em>data
packets</em>. In principle you could simply <tt>cat</tt> valid PGP
files to form a bigger valid PGP file, though applications may reject
the semantics of such a file.

Each packet is formatted in a classic <a
href="https://en.wikipedia.org/wiki/Type-length-value">tag-length-value</a>
style. It starts with a tag field that tells you what sort of of a
packet it is. This is followed by a length field, saying how many
bytes long the following payload is. Then comes the payload for the
packet.

<img src="/media/img/cd794c580e6792484785a2cad9f79fe6fd4d4fd3.png" class="half" alt="key with tags"/>
Here is the same key I used before, but now with just its tag and
length fields highlighted in shades of blue. You should see five
packets in it.

What are these five packets? It turns out that what we usually call a
"PGP public key" is really a list of many public keys, signatures,
etc.  The specification uses the term <em>OpenPGP certificate</em> rather
than "public key" to avoid confusion, and I'll start calling it a
certificate too.

$asis
<div class="clear"></div>

<img src="/media/img/db48df51560ba1b0c74b353559a2773a227f45c4.png" alt="public packets in key" class="half"/>
The first and fourth packets are <em>public key</em> packets. If you use
RSA (as this certificate does) you normally use different public keys
for encryption and signing for cryptographic safety. The first public
key -- the so-called master key -- is what actually identifies the
certificate and forms your PGP fingerprint. However, if someone wants
to send you a message, they'll encrypt it with the second public key
found in the certificate.

Each public key has a small header that describes its type (RSA, etc)
followed by a list of integers, which are the actual values used in
the public key algorithm. Each integer has a length field followed by
a sequence of bytes for the integer.

The integers are the large green sections above, each preceded by a
two-byte length in light blue-green. RSA uses two numbers in its
public-key method, and you should see two integers in each packet. You
may wonder why the first number in each packet is so much longer than
the second. The big number is 2048 bits long, and is product of two
large primes that only the owner of this key knows. The small number
is an exponent used by RSA, and it turns out that the same small prime
<a
href="https://en.wikipedia.org/wiki/65537_(number)#Applications">65537</a>,
is always used in practice.

<img src="/media/img/7c079f2b26c8b6d9f2ecfaa855566cf812f64a08.png" alt="user id packet in key" class="half"/>
The second packet is a <em>user id</em> packet, highlighted here in
yellow. You can see that it's simply a sequence of ASCII (actually,
UTF-8) bytes. This certificate is indeed Linus' PGP certificate, which
he also uses to sign git tags during Linux development.

$asis
<div class="clear"></div>

<img src="/media/img/f0cffe8d4e7102e2365627a7b6e8aa317de30d0b.png"
alt="signature packet in key" class="half"/>
The third and fifth packets are <em>signature packets</em>, which are
rather complex. An RSA signature ends with a large number, here seen
in green and preceded by its two-byte length in pale blue-green. It is
in the same format as the large numbers found in the public key. This
number is the signature used to verify the data being signed.

You will see a two-byte white area in each packet. OpenPGP originally
used it to hold a "quick-check" hash of the data to let
implementations quickly reject bad files without needing to run the
more expensive cryptographic signature check. However, someone <a
href="https://eprint.iacr.org/2005/033.pdf">discovered a
chosen-plaintext attack</a> if implementations actually used these
bytes as intended. So in practice, these two bytes are just ignored.

$asis
<div class="clear"></div>

An OpenPGP signature has an additional purpose, it adds metadata to
the thing it is signing. For instance, it includes the type of
signature, the time it was signed, and other metadata specific to a
given type of signature.

Surprisingly, this metadata itself doesn't have to be completely
signed, and a signature typically contains both signed and unsigned
metadata. The signed metadata in this key is in dark purple, followed
by the unsigned metadata in light purple. If you look carefully,
you'll also see that each metadata sequence is preceded by a two-byte
length header in a different shade of purple.

The first signature packet is a <em>self-signature</em>, indicating that it
applies to the preceding master public key and the user ID packet. The
signature is created using the master key itself. It's really just a
way to prove that nobody has changed the public key, connect the user
id with that key, and add metadata about the key like the preferred
cryptographic algorithms to use when communicating with the owner,
etc.

The second signature packet is a <em>sub-key signature</em>, indicating
that it is a signature on the second public key packet. This signature
is also created using the master key, and the metadata on this
signature tells you to use this second public key for encryption. If
you trust the first public key, verifying this signature lets you
trust the second public key as well.

$asis
<h2>Structure + heatmap = insight</h2>

If you're still with me, here's the payoff. We can overlay the heatmap
on top of the data structures in the certificate, and look for
correlations.

$asis
<div class="relative_flip" style="width: 328px; height: 264px;">
  <div style="position: absolute; top: 0; left: 0">
    <img src="/media/img/4524b8d586c608dcb12c64a06b7f67732d6ce9f5.png" alt="key structure"/>
  </div>
  <div class="show_onhover" style="position: absolute; top: 0; left: 0;">
    <img src="/media/img/502abd76f3682563debb6c0b7f342d224b17a402.png" alt="heatmap"/>
  </div>
</div>

(Mouseover the image to show the heatmap on top of the packets.)

You can immediately see what's going on with the second half of the
key. <tt>gpg</tt> generally imports the key if we're fuzzing bytes starting
with the second public key. In fact, what <tt>gpg</tt> actually does is to
only import the master key, but not the encryption key. This doesn't
cause problems, and is arguably a best-effort by <tt>gpg</tt> to use what
keys it can extract from the certificate.

What's a bit more interesting is that it doesn't consistently import
the first key in this situation. It appears that fuzzing certain bytes
in the second key can cause it to reject the first key as well. For
example, changing the length field of the big number in the second
public key causes it to reject the entire certificate. One thing you
can conclude is that <tt>gpg</tt> probably uses a two-pass approach to
import keys, as keys are not imported as soon as they are verified.

If you look carefully you'll soon notice that most of the problems are
around the length fields of a packet or the length field of a data
structure within a packet. This is a common issue with most code that
parses binary data.

For example, take the very first pale red spot in the first public-key
packet. You'll notice it occurs within the length field of the small
second number of the master key.

The length field here counts the number of bits to use from the
following bytes, and the spec also demands that it never contain
leading zeros. The length field on the second number is 17 bits, but
if you change it to (say) 18 bits, <tt>gpg</tt> fails to flag it as an
error because the parser fails to check for leading zeros as the spec
requires. But it still remains the same number, and doesn't cause
obvious problems. So, a minor bug in <tt>gpg</tt>.

More importantly, why doesn't the signature verification fail even
though we've altered bytes in the public key packet?  It turns out
that self-signatures don't sign raw bytes in the public key. What they
actually sign is a canonical representation of these numbers <em>after</em>
they have been parsed. So, a subtle bug in data parsing like this is
not detectable by OpenPGP self-signatures.

You will find a similar situation with the red blob on top of the user
id tag byte. It turns out that there are two different, but correct
ways to represent a user id tag. This packet too is transformed into a
canonical form before parsing, and hence not detectable by the
signature.

Another interesting area is the length field on the signature
packets. Look for two fairly red bytes right after the user packet and
on the length field of the signature packet. Why does <tt>gpg</tt> mostly
accept the key even if these bytes are changed?

Each data structure within a signature is either a fixed size, or has
a length, and <tt>gpg</tt> uses this information to parse the signature
packet and generally ignores the overall signature length.  As you
might guess -- the signature packet length is not part of the
signature, so it is not detected during verification.

You can also fuzz parts of the unsigned meta-data as well, which is to
be expected.

Ok. None of these look like major problems, so where is <a
href="http://www.securityfocus.com/bid/57102/info">the
vulnerability</a> in <tt>gpg</tt> anyway? It was a combination of its
two-pass approach to add keys, together with with incorrectly cleaning
up data structures after it failed to parse a fuzzed packet. This
happened when fuzzing the bytes that start the second public
key. Normally, it is unable to parse the rest of the data as you might
expect; but every so often it would misidentify it as a completely
different packet, run into errors parsing that packet, and then fail
to clean up the partially created data structures.

This wouldn't have caused a real problem, except that when <tt>gpg</tt>
went back to add the first key, it traversed some of these bad data
structures and landed into memory-access trouble. The fix was to
<a href="http://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=patch;h=f795a0d59e197455f8723c300eebf59e09853efa">skip parsing packets</a>
in public key certificates if it hit one of the bad packet types.

By now, you might be wondering about other types of fuzzing
attacks. For instance, could you reorder OpenPGP packets and see what
happens, and so on. These are of course good ways to continue testing,
and starts to enter a technique called "generative" fuzzing. This uses
a deeper knowledge of the data, and typically tries to generate
(rather than mutate) funny inputs.

Generative fuzzing is very useful, though it usually takes more effort
because you need to understand the format of the data to be effective.
I've focused on mutative fuzzing because it's pretty useful just by
itself, and takes very little effort to do.

$asis
<h2>Conclusions</h2>

What did I learn from all this, including the bugs I found in my own
app?

In the math behind cryptography, you can prove certain bounds that
help you understand its "goodness". But in practical cryptographic
code, there's isn't a way to know how secure it really is without
testing it. So testing is a necessary (though not sufficient) way to
understand the security of the system.

A surprisingly effective test is to blindly and randomly bash at all
the inputs to your application.  In fact, variations of this method
are <a
href="https://en.wikipedia.org/wiki/Automatic_test_pattern_generation">widely
used in hardware design</a> and I've been been guilty of not paying
enough attention to it.

Also, complex data formats and protocols greatly increase the chances
of security bugs in any implementation, and it's not a linear
increase with complexity.

Code to handle increasing complexity quickly hits a threshold where
you cannot simply intellectually analyze it for security holes. It
also gets worse if parts of the code are implemented by different
people.

So if you're designing a new security-related format or protocol, it's
just as important to keep it simple to make the implementations more
secure.
